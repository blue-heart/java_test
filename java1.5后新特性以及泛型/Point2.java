package com.bittech;
//一个类写源码
//一个类写主函数
//这就是访问权限允许
//参数类型可以有引用
//传参 new 也是一样的道理
//知道属性和变量名区别

/*
泛型类：
1.类名<类型参数>
2.泛型类的属性类型使用类型参数
3.泛型类实例化对象时，变量类型
中指定类型参数的 具体类型 构造
方法可以省略类型参数的具体类型
一般不要省略 但没事 会提示警告
<> 不能省略
属性的类型 即是 类型参数的具体类型
但是 属性类型必须是泛型类型
否则 编译也检查不出来
 使用了 类型参数的属性类型即是
 类型参数的具体类型 必须是引用数据类型
 如果想要基本数据类型 就用包装类型
 这下就打通了 知识

 泛型类的类型可以定义多个，用逗号隔开
 注意 字母不能重复 而且两种都可以定义为同一类型
 完全不需要转型 有个instance关键字
 不用转 完全用不上 但有时也要转

 泛型方法：
 1.独立定义（可以单独定义泛型方法
 ，和类没有直接关系）
 2.泛型方法的类型参数在方法的返回值
 类型的前面定义<T ...>
 3.泛型方法的类型参数：方法之间没有关系，
 和类也没有关系

 通配符:
 如果不是 一般方法 就调用不了实例化化后的对象
 参数类型不一样
 1.?可以接收任意参数的类型，但是不能被修改
 泛型得通过构造方法实例化 确定对象
 已经实例化过 就不能该改 调用setter
 必须再创建一个对象实例化
 2. ？ extends classType ： 泛型的上限 ？
 类型是classtYpe 或者子类
 上限：eg：T extends classType
 应用到类 方法
 应用到方法中仍然不能修改
 3.？ super classType ： 泛型的下限
 类型 是他或者父类
 应用到方法 中内容可以修改
 主要修改的是自己和子类类型
 实例化的数据类型锁定

 泛型接口：
 1.在定义接口时，声明类型参数
 2.实现
 第一种： 实现类保留类型参数
 imlementClassType《T》 implements
 interfaceClassType《T》
 使用的时候 和泛型类使用方式一致
 使用时需要指定 具体参数类型
 第二种：
 实现类不保留参数类型，实现的确定了参数类型
 imlementClassType implements
 interfaceClassType《String》
 使用时和普通类一样

 泛型类在jvm中就是普通类
 只不过是让编译数据类型不兼容的错误通过
 仅仅存在于 编译阶段
 */



public class Point2<T> {
    private T x;
    private T y;

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}
